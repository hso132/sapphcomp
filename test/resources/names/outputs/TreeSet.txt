Trees after name analysis
object L_0 {

  abstract class List_0

  case class Nil_0() extends List_0

  case class Cons_0(v: Int, v: List_0) extends List_0

  def isEmpty_0(l_0: List_0): Boolean = {
    l_0 match {
      case Nil_0() =>
        true
      case _ =>
        false
    }
  }

  def length_0(l_1: List_0): Int = {
    l_1 match {
      case Nil_0() =>
        0
      case Cons_0(_, t_0) =>
        (1 + length_0(t_0))
    }
  }

  def head_0(l_2: List_0): Int = {
    l_2 match {
      case Cons_0(h_0, _) =>
        h_0
      case Nil_0() =>
        error("head(Nil)")
    }
  }

  def headOption_0(l_3: List_0): Option_0 = {
    l_3 match {
      case Cons_0(h_1, _) =>
        Some_0(h_1)
      case Nil_0() =>
        None_0()
    }
  }

  def reverse_0(l_4: List_0): List_0 = {
    reverseAcc_0(l_4, Nil_0())
  }

  def reverseAcc_0(l_5: List_0, acc_0: List_0): List_0 = {
    l_5 match {
      case Nil_0() =>
        acc_0
      case Cons_0(h_2, t_1) =>
        reverseAcc_0(t_1, Cons_0(h_2, acc_0))
    }
  }

  def indexOf_0(l_6: List_0, i_0: Int): Int = {
    l_6 match {
      case Nil_0() =>
        -(1)
      case Cons_0(h_3, t_2) =>
        (if((h_3 == i_0)) {
          0
        } else {
          (
            val rec_0: Int =
              indexOf_0(t_2, i_0);
            (if((0 <= rec_0)) {
              (rec_0 + 1)
            } else {
              -(1)
            })
          )
        })
    }
  }

  def range_0(from_0: Int, to_0: Int): List_0 = {
    (if((to_0 < from_0)) {
      Nil_0()
    } else {
      Cons_0(from_0, range_0((from_0 + 1), to_0))
    })
  }

  def sum_0(l_7: List_0): Int = {
    l_7 match {
      case Nil_0() =>
        0
      case Cons_0(h_4, t_3) =>
        (h_4 + sum_0(t_3))
    }
  }

  def concat_0(l1_0: List_0, l2_0: List_0): List_0 = {
    l1_0 match {
      case Nil_0() =>
        l2_0
      case Cons_0(h_5, t_4) =>
        Cons_0(h_5, concat_0(t_4, l2_0))
    }
  }

  def contains_0(l_8: List_0, elem_0: Int): Boolean = {
    l_8 match {
      case Nil_0() =>
        false
      case Cons_0(h_6, t_5) =>
        ((h_6 == elem_0) || contains_0(t_5, elem_0))
    }
  }

  abstract class LPair_0

  case class LP_0(v: List_0, v: List_0) extends LPair_0

  def merge_0(l1_1: List_0, l2_1: List_0): List_0 = {
    l1_1 match {
      case Nil_0() =>
        l2_1
      case Cons_0(h1_0, t1_0) =>
        l2_1 match {
          case Nil_0() =>
            l1_1
          case Cons_0(h2_0, t2_0) =>
            (if((h1_0 <= h2_0)) {
              Cons_0(h1_0, merge_0(t1_0, l2_1))
            } else {
              Cons_0(h2_0, merge_0(l1_1, t2_0))
            })
        }
    }
  }

  def split_0(l_9: List_0): LPair_0 = {
    l_9 match {
      case Cons_0(h1_1, Cons_0(h2_1, t_6)) =>
        (
          val rec_1: LPair_0 =
            split_0(t_6);
          rec_1 match {
            case LP_0(rec1_0, rec2_0) =>
              LP_0(Cons_0(h1_1, rec1_0), Cons_0(h2_1, rec2_0))
          }
        )
      case _ =>
        LP_0(l_9, Nil_0())
    }
  }

  def mergeSort_0(l_10: List_0): List_0 = {
    l_10 match {
      case Nil_0() =>
        l_10
      case Cons_0(h_7, Nil_0()) =>
        l_10
      case l_11 =>
        split_0(l_11) match {
          case LP_0(l1_2, l2_2) =>
            merge_0(mergeSort_0(l1_2), mergeSort_0(l2_2))
        }
    }
  }

  def toString_0(l_12: List_0): String = {
    l_12 match {
      case Nil_0() =>
        "List()"
      case more_0 =>
        (("List(" ++ toString1_0(more_0)) ++ ")")
    }
  }

  def toString1_0(l_13: List_0): String = {
    l_13 match {
      case Cons_0(h_8, Nil_0()) =>
        intToString_0(h_8)
      case Cons_0(h_9, t_7) =>
        ((intToString_0(h_9) ++ ", ") ++ toString1_0(t_7))
    }
  }

  def take_0(l_14: List_0, n_0: Int): List_0 = {
    (if((n_0 <= 0)) {
      Nil_0()
    } else {
      l_14 match {
        case Nil_0() =>
          Nil_0()
        case Cons_0(h_10, t_8) =>
          Cons_0(h_10, take_0(t_8, (n_0 - 1)))
      }
    })
  }
}


object O_0 {

  abstract class Option_0

  case class None_0() extends Option_0

  case class Some_0(v: Int) extends Option_0

  def isDefined_0(o_0: Option_0): Boolean = {
    o_0 match {
      case None_0() =>
        false
      case _ =>
        true
    }
  }

  def get_0(o_1: Option_0): Int = {
    o_1 match {
      case Some_0(i_1) =>
        i_1
      case None_0() =>
        error("get(None)")
    }
  }

  def getOrElse_0(o_2: Option_0, i_2: Int): Int = {
    o_2 match {
      case None_0() =>
        i_2
      case Some_0(oo_0) =>
        oo_0
    }
  }

  def orElse_0(o1_0: Option_0, o2_0: Option_0): Option_0 = {
    o1_0 match {
      case Some_0(_) =>
        o1_0
      case None_0() =>
        o2_0
    }
  }

  def toList_0(o_3: Option_0): List_0 = {
    o_3 match {
      case Some_0(i_3) =>
        Cons_0(i_3, Nil_0())
      case None_0() =>
        Nil_0()
    }
  }
}


object Std_0 {

  def printInt_0(i_4: Int): Unit = {
    error("")
  }

  def printString_0(s_0: String): Unit = {
    error("")
  }

  def printBoolean_0(b_0: Boolean): Unit = {
    printString_0(booleanToString_0(b_0))
  }

  def readString_0(): String = {
    error("")
  }

  def readInt_0(): Int = {
    error("")
  }

  def intToString_0(i_5: Int): String = {
    (if((i_5 < 0)) {
      ("-" ++ intToString_0(-(i_5)))
    } else {
      (
        val rem_0: Int =
          (i_5 % 10);
        val div_0: Int =
          (i_5 / 10);
        (if((div_0 == 0)) {
          digitToString_0(rem_0)
        } else {
          (intToString_0(div_0) ++ digitToString_0(rem_0))
        })
      )
    })
  }

  def digitToString_0(i_6: Int): String = {
    error("")
  }

  def booleanToString_0(b_1: Boolean): String = {
    (if(b_1) {
      "true"
    } else {
      "false"
    })
  }
}


object TreeSet_0 {

  abstract class TreeNode_0

  case class Node_0(v: Int, v: TreeNode_0, v: TreeNode_0) extends TreeNode_0

  case class Leaf_0() extends TreeNode_0

  def insert_0(tree_0: TreeNode_0, i_7: Int): TreeNode_0 = {
    tree_0 match {
      case Leaf_0() =>
        Node_0(i_7, Leaf_0(), Leaf_0())
      case Node_0(v_0, l_15, r_0) =>
        (if((v_0 < i_7)) {
          (
            val rNode_0: TreeNode_0 =
              insert_0(r_0, i_7);
            Node_0(v_0, l_15, rNode_0)
          )
        } else {
          (if((i_7 < v_0)) {
            (
              val lNode_0: TreeNode_0 =
                insert_0(l_15, i_7);
              Node_0(v_0, lNode_0, r_0)
            )
          } else {
            tree_0
          })
        })
    }
  }

  def contains_1(tree_1: TreeNode_0, i_8: Int): Boolean = {
    tree_1 match {
      case Leaf_0() =>
        false
      case Node_0(v_1, l_16, r_1) =>
        (if((v_1 == i_8)) {
          true
        } else {
          (if((v_1 < i_8)) {
            contains_1(r_1, i_8)
          } else {
            contains_1(l_16, i_8)
          })
        })
    }
  }

  def maxDepth_0(tree_2: TreeNode_0): Int = {
    tree_2 match {
      case Leaf_0() =>
        0
      case Node_0(v_2, l_17, r_2) =>
        (
          val left_0: Int =
            maxDepth_0(l_17);
          val right_0: Int =
            maxDepth_0(r_2);
          val max_0: Int =
            (if((right_0 < left_0)) {
              left_0
            } else {
              right_0
            });
          (max_0 + 1)
        )
    }
  }

  def size_0(tree_3: TreeNode_0): Int = {
    tree_3 match {
      case Leaf_0() =>
        0
      case Node_0(_, l_18, r_3) =>
        ((size_0(l_18) + size_0(r_3)) + 1)
    }
  }

  def printContains_0(argTree_0: TreeNode_0, num_0: Int): Unit = {
    printString_0(((intToString_0(num_0) ++ " is in tree: ") ++ booleanToString_0(contains_1(argTree_0, num_0))))
  }

  val tree_4: TreeNode_0 =
    insert_0(insert_0(insert_0(insert_0(insert_0(Leaf_0(), 5), 6), 3), 100), 1);
  printContains_0(tree_4, 5);
  printContains_0(tree_4, 6);
  printContains_0(tree_4, 7);
  printString_0(("Max Depth: " ++ intToString_0(maxDepth_0(tree_4))));
  printString_0(("Size: " ++ intToString_0(size_0(tree_4))));
  ()
}

